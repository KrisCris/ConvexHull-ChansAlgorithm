(function(){var e={613:function(e,t,s){"use strict";var n=s(9963),o=s(6252);function r(e,t,s,n,r,a){const i=(0,o.up)("router-view");return(0,o.wg)(),(0,o.j4)(i)}var a={name:"App",methods:{resizeWatcher(){clearTimeout(this.$store.state.resizeTimeoutId),this.$store.state.resizeTimeoutId=setTimeout((()=>{const e=document.getElementById("svg");if(void 0==e)return void(this.$store.state.resizeRequired=!0);const t=e.getBoundingClientRect();this.$store.commit("updatePosition",{width:t.width,height:t.height})}),500)}},mounted(){window.addEventListener("resize",this.resizeWatcher)},unmounted(){window.removeEventListener("resize",this.resizeWatcher)}},i=s(3744);const l=(0,i.Z)(a,[["render",r]]);var u=l,d=s(2201);const c=(0,o.uE)('<div class="about"><div class="divider"><h1>Description</h1><p> This is my final project for the <a target="_blank" rel="noopener noreferrer" href="https://www.cse.wustl.edu/~taoju/cse546/">CSE546: Computational Geometry</a> course, taught by <a target="_blank" rel="noopener noreferrer" href="https://www.cse.wustl.edu/~taoju/">Professor Tao Ju</a>, at Washington University in St. Louis. </p><p> It demos <a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/wiki/Chan%27s_algorithm">Chan&#39;s Algorithm</a>, an optimal output-sensitive algorithm computing the convex hull of a point set. </p></div><div class="divider"><h1>Developers</h1><div class="devs"><p><a target="_blank" rel="noopener noreferrer" href="https://github.com/KrisCris">Pingchuan Huang</a> (Main)</p><p><a target="_blank" rel="noopener noreferrer" href="https://github.com/CocoYard">Yong Cheng</a></p></div></div><div class="divider"><h1>Git Repo</h1><div><p><a target="_blank" rel="noopener noreferrer" href="https://github.com/KrisCris/ConvexHull-ChansAlgorithm">https://github.com/KrisCris/ConvexHull-ChansAlgorithm</a></p></div></div><div class="divider"><h1>Packages Used</h1><div class="packages"><p><a target="_blank" rel="noopener noreferrer" href="https://vuejs.org/">Vue.js</a></p><a target="_blank" rel="noopener noreferrer" href="https://github.com/internalfx/distinct-colors"><p>distinct-colors</p></a></div></div><div class="divider"><h1>References</h1><div class="refs"><a target="_blank" rel="noopener noreferrer" href="https://sites.cs.ucsb.edu/~suri/cs235/ChanCH.pdf"><p>1. Chan, T.M. Optimal output-sensitive convex hull algorithms in two and three dimensions</p></a><a target="_blank" rel="noopener noreferrer" href="http://www.cs.umd.edu/~mount/754/Lects/754lects.pdf"><p>2. Dave Mount&#39;s Lecture Notes</p></a></div></div></div>',1);function h(e,t,s,n,r,a){const i=(0,o.up)("Nav");return(0,o.wg)(),(0,o.iD)(o.HY,null,[(0,o.Wm)(i),c],64)}var p=s(3577);const g={id:"nav",class:"top"};function m(e,t,s,r,a,i){const l=(0,o.up)("router-link");return(0,o.wg)(),(0,o.iD)("div",g,[(0,o.Wm)(l,{to:{name:"Chans"}},{default:(0,o.w5)((()=>[(0,o.Uk)("Chan's Algorithm")])),_:1}),(0,o.Wm)(l,{to:{name:"About"}},{default:(0,o.w5)((()=>[(0,o.Uk)("About ")])),_:1}),i.isPadPage?((0,o.wg)(),(0,o.iD)("a",{key:0,id:"settingsBtn",class:"settingsBtn",href:"#",onClick:t[0]||(t[0]=e=>a.settings=!a.settings)},"âš™")):(0,o.kq)("",!0),a.settings?((0,o.wg)(),(0,o.iD)("div",{key:1,id:"settingsPanel",class:"settings",style:(0,p.j5)({top:i.top()+"px",right:i.right()+"px"})},[(0,o._)("p",null,"Animation Duration ("+(0,p.zw)(i.speed)+" ms)",1),(0,o.wy)((0,o._)("input",{type:"range","onUpdate:modelValue":t[1]||(t[1]=e=>i.speed=e),min:"10",max:"200",step:"10"},null,512),[[n.nr,i.speed]])],4)):(0,o.kq)("",!0)])}var f={name:"Nav",mounted(){document.addEventListener("click",this.disableSettings)},methods:{top(){return document.querySelector("#nav").clientHeight+5},right(){return window.innerWidth-document.querySelector(".settingsBtn").offsetLeft-document.querySelector(".settingsBtn").offsetWidth/2},disableSettings(e){const t=document.querySelector("#settingsPanel"),s=document.querySelector("#settingsBtn");!t||t.contains(e.target)||s.contains(e.target)||(this.settings=!1)}},data(){return{settings:!1}},computed:{speed:{get(){return this.$store.state.speed},set(e){this.$store.commit("setSpeed",e)}},isPadPage(){return"Chans"===this.$route.name}}};const v=(0,i.Z)(f,[["render",m]]);var w=v,k={name:"About",components:{Nav:w}};const b=(0,i.Z)(k,[["render",h]]);var y=b;const P={class:"row"},x={class:"col"};function _(e,t,s,n,r,a){const i=(0,o.up)("Nav"),l=(0,o.up)("SketchPad"),u=(0,o.up)("ControlPanel");return(0,o.wg)(),(0,o.iD)("div",P,[(0,o.Wm)(i),(0,o._)("div",x,[(0,o.Wm)(l),(0,o.Wm)(u)])])}const S={class:"sketchpad"},C=["x1","x2","y1","y2"],R=["x1","x2","y1","y2"],$=["x1","x2","y1","y2"],U=["cx","cy","r"];function E(e,t,s,n,r,a){return(0,o.wg)(),(0,o.iD)("div",S,[((0,o.wg)(),(0,o.iD)("svg",{id:"svg",onClick:t[0]||(t[0]=(...e)=>a.addPoint&&a.addPoint(...e))},[((0,o.wg)(!0),(0,o.iD)(o.HY,null,(0,o.Ko)(a.edges,(e=>((0,o.wg)(),(0,o.iD)("line",{key:e,x1:e.x0,x2:e.x1,y1:e.y0,y2:e.y1,style:(0,p.j5)({stroke:e.color,"stroke-width":2})},null,12,C)))),128)),a.scanEdge?((0,o.wg)(),(0,o.iD)("line",{key:0,x1:a.scanEdge.x0,x2:a.scanEdge.x1,y1:a.scanEdge.y0,y2:a.scanEdge.y1,style:{stroke:"white","stroke-width":2}},null,8,R)):(0,o.kq)("",!0),((0,o.wg)(!0),(0,o.iD)(o.HY,null,(0,o.Ko)(a.fullHullEdges,(e=>((0,o.wg)(),(0,o.iD)("line",{key:e,x1:e.x0,x2:e.x1,y1:e.y0,y2:e.y1,style:(0,p.j5)({stroke:e.color,"stroke-width":4})},null,12,$)))),128)),((0,o.wg)(!0),(0,o.iD)(o.HY,null,(0,o.Ko)(a.vertices,(e=>((0,o.wg)(),(0,o.iD)("circle",{key:e,cx:e.xPos,cy:e.yPos,r:e.getR(),style:(0,p.j5)({fill:e.color})},null,12,U)))),128))]))])}var H={name:"Sketchpad",computed:{vertices(){return this.$store.getters.vertices},edges(){return this.$store.getters.edges},scanEdge(){return this.$store.state.scanEdge},fullHullEdges(){return this.$store.state.fullHullEdges}},methods:{addPoint(e){this.$store.commit("addVertex",{x:e.offsetX,y:e.offsetY})}},mounted(){if(this.$store.state.resizeRequired){const e=document.getElementById("svg").getBoundingClientRect();this.$store.commit("updatePosition",{width:e.width,height:e.height})}}};const M=(0,i.Z)(H,[["render",E]]);var D=M;const W={class:"ControlPanel"},q={key:0,class:"warpper"},N={class:"description"},V={class:"content"},A=(0,o._)("h1",null,"Welcome!",-1),T=(0,o._)("a",{target:"_blank",rel:"noopener noreferrer",href:"https://en.wikipedia.org/wiki/Chan%27s_algorithm"},"Chan's algorithm",-1),j={class:"controllor"},O={class:"content"},z={key:1,class:"warpper"},I=(0,o._)("div",{class:"description"},[(0,o._)("div",{class:"content"},[(0,o._)("h2",null,"1. Draw Some Points"),(0,o._)("p",null," Let's first add some points (more than 3) by simply clicking on the empty plane! "),(0,o._)("p",null," Or, a number of points can be added automatically via the slider and the button below. "),(0,o._)("p",null," Note: You can change the animation duration from the settings. ")])],-1),Z={class:"controllor"},G={class:"content"},L=["disabled"],F=(0,o._)("br",null,null,-1),J={class:"btnGroup"},B=["disabled"],Y=["disabled"],K=["disabled"],X={key:2,class:"warpper"},Q={class:"description"},ee={class:"content"},te=(0,o._)("h2",null,"2. How it works",-1),se=(0,o._)("a",{target:"_blank",rel:"noopener noreferrer",href:"https://en.wikipedia.org/wiki/Graham_scan"},"Graham's scan",-1),ne=(0,o._)("a",{target:"_blank",rel:"noopener noreferrer",href:"https://en.wikipedia.org/wiki/Gift_wrapping_algorithm"},"Jarvis's march",-1),oe={class:"controllor"},re={class:"content"},ae={class:"btnGroup"},ie={key:3,class:"warpper"},le={class:"description"},ue={class:"content"},de={key:0},ce={key:1},he=(0,o._)("p",{class:"val"},[(0,o.Uk)("m = min { 2"),(0,o._)("sup",null,[(0,o.Uk)("2"),(0,o._)("sup",null,"t")]),(0,o.Uk)(", n }, t = #iteration")],-1),pe=(0,o._)("sup",null,[(0,o.Uk)("t"),(0,o._)("sup",null,"2")],-1),ge={key:2},me={key:3},fe={key:4},ve={key:5},we={key:6},ke={key:7},be=(0,o._)("sup",null,[(0,o.Uk)("2"),(0,o._)("sup",null,"t")],-1),ye={key:8},Pe={class:"controllor"},xe={class:"content"},_e={class:"btnGroup"},Se=["disabled"],Ce=["disabled"],Re=["disabled"],$e=["disabled"],Ue=["disabled"],Ee=["disabled"],He=["disabled"],Me=["disabled"],De={key:4,class:"warpper"},We=(0,o._)("div",{class:"description"},[(0,o._)("div",{class:"content"},[(0,o._)("h2",null,"The Playground"),(0,o._)("p",null," Feel free to test more m values! ")])],-1),qe={class:"controllor"},Ne={class:"content"},Ve={class:"mSettings"},Ae=["disabled"],Te=["disabled"],je={class:"mSettings"},Oe=["disabled"],ze=["disabled"],Ie=["disabled"];function Ze(e,t,s,r,a,i){const l=(0,o.up)("tag");return(0,o.wg)(),(0,o.iD)("div",W,[0==e.$store.state.step?((0,o.wg)(),(0,o.iD)("div",q,[(0,o._)("div",N,[(0,o._)("div",V,[A,(0,o._)("p",null,[(0,o.Uk)(" This is a demo of "),T,(0,o.Uk)(", named after Timothy M. Chan, an optimal output-sensitive algorithms that construct the convex hull of a set of "),(0,o.Wm)(l,{class:"val"},{default:(0,o.w5)((()=>[(0,o.Uk)("n")])),_:1}),(0,o.Uk)(" points in two or three dimensions in worst-case optimal "),(0,o.Wm)(l,{class:"val"},{default:(0,o.w5)((()=>[(0,o.Uk)("O(n log h)")])),_:1}),(0,o.Uk)(" time and "),(0,o.Wm)(l,{class:"val"},{default:(0,o.w5)((()=>[(0,o.Uk)("O(n)")])),_:1}),(0,o.Uk)(" space, where "),(0,o.Wm)(l,{class:"val"},{default:(0,o.w5)((()=>[(0,o.Uk)(" h")])),_:1}),(0,o.Uk)(" denotes the number of vertices of the convex hull. ")])])]),(0,o._)("div",j,[(0,o._)("div",O,[(0,o._)("button",{onClick:t[0]||(t[0]=(...e)=>i.nextStep&&i.nextStep(...e))},"Start")])])])):(0,o.kq)("",!0),1==e.$store.state.step?((0,o.wg)(),(0,o.iD)("div",z,[I,(0,o._)("div",Z,[(0,o._)("div",G,[(0,o.wy)((0,o._)("input",{disabled:!e.$store.state.canRun,type:"range",min:"1",max:"100",step:"1",name:"pointsNum",id:"","onUpdate:modelValue":t[1]||(t[1]=e=>a.pointsNum=e)},null,8,L),[[n.nr,a.pointsNum]]),F,(0,o._)("div",J,[(0,o._)("button",{disabled:!e.$store.state.canRun,onClick:t[2]||(t[2]=(...e)=>i.addPoints&&i.addPoints(...e))}," Add "+(0,p.zw)(a.pointsNum)+" Points ",9,B),(0,o._)("button",{disabled:!(e.$store.state.canRun&&i.enoughPoints),class:"green",onClick:t[3]||(t[3]=(...e)=>i.nextStep&&i.nextStep(...e))}," Next ",8,Y),(0,o._)("button",{disabled:!e.$store.state.canRun,class:"gray",onClick:t[4]||(t[4]=(...e)=>i.prevStep&&i.prevStep(...e))}," Prev ",8,K)])])])])):(0,o.kq)("",!0),2==e.$store.state.step?((0,o.wg)(),(0,o.iD)("div",X,[(0,o._)("div",Q,[(0,o._)("div",ee,[te,(0,o._)("p",null,[(0,o.Uk)(" Choose a parameter "),(0,o.Wm)(l,{class:"val"},{default:(0,o.w5)((()=>[(0,o.Uk)("m")])),_:1}),(0,o.Uk)(" between "),(0,o.Wm)(l,{class:"val"},{default:(0,o.w5)((()=>[(0,o.Uk)("1")])),_:1}),(0,o.Uk)(" and "),(0,o.Wm)(l,{class:"val"},{default:(0,o.w5)((()=>[(0,o.Uk)("n ")])),_:1}),(0,o.Uk)(" and partition the points of size "),(0,o.Wm)(l,{class:"val"},{default:(0,o.w5)((()=>[(0,o.Uk)("n")])),_:1}),(0,o.Uk)(" into "),(0,o.Wm)(l,{class:"val"},{default:(0,o.w5)((()=>[(0,o.Uk)("âŒˆn/mâŒ‰")])),_:1}),(0,o.Uk)(" groups of equal size at most "),(0,o.Wm)(l,{class:"val"},{default:(0,o.w5)((()=>[(0,o.Uk)("m")])),_:1}),(0,o.Uk)(". Compute the convex hull of each group using "),se,(0,o.Uk)(". Then, wrapping the shape using "),ne,(0,o.Uk)(" on these groups for at most "),(0,o.Wm)(l,{class:"val"},{default:(0,o.w5)((()=>[(0,o.Uk)("m")])),_:1}),(0,o.Uk)(" steps. ")]),(0,o._)("p",null,[(0,o.Uk)(" Since the value of "),(0,o.Wm)(l,{class:"val"},{default:(0,o.w5)((()=>[(0,o.Uk)("h")])),_:1}),(0,o.Uk)(" is unknown, we use a sequence of "),(0,o.Wm)(l,{class:"val"},{default:(0,o.w5)((()=>[(0,o.Uk)("m ")])),_:1}),(0,o.Uk)('\'s to "guess" its value, until the convex hull is successfully computed. ')])])]),(0,o._)("div",oe,[(0,o._)("div",re,[(0,o._)("div",ae,[(0,o._)("button",{class:"green",onClick:t[5]||(t[5]=(...e)=>i.nextStep&&i.nextStep(...e))},"Demo"),(0,o._)("button",{class:"gray",onClick:t[6]||(t[6]=(...e)=>i.prevStep&&i.prevStep(...e))},"Prev")])])])])):(0,o.kq)("",!0),3==e.$store.state.step?((0,o.wg)(),(0,o.iD)("div",ie,[(0,o._)("div",le,[(0,o._)("div",ue,[e.$store.state.subStep<3?((0,o.wg)(),(0,o.iD)("h2",de,"Step "+(0,p.zw)(e.$store.state.subStep+1)+"/3",1)):(0,o.kq)("",!0),0==e.$store.state.subStep?((0,o.wg)(),(0,o.iD)("p",ce,[(0,o.Uk)(" To find the value "),(0,o.Wm)(l,{class:"val"},{default:(0,o.w5)((()=>[(0,o.Uk)("m")])),_:1}),(0,o.Uk)(" that computes the convex hull, The first step is dividing the points of size "),(0,o.Wm)(l,{class:"val"},{default:(0,o.w5)((()=>[(0,o.Uk)("n")])),_:1}),(0,o.Uk)(" into groups of each of size "),(0,o.Wm)(l,{class:"val"},{default:(0,o.w5)((()=>[(0,o.Uk)("m")])),_:1}),(0,o.Uk)(", where "),he,(0,o._)("p",null,[(0,o.Uk)(" Note: As suggested in Idea 4 in the material, the sequence of "),(0,o.Wm)(l,{class:"val"},{default:(0,o.w5)((()=>[(0,o.Uk)("m = 2"),pe,(0,o.Uk)(", t = 2, 3, ...")])),_:1}),(0,o.Uk)(" might works better for 2D. ")])])):(0,o.kq)("",!0),1==e.$store.state.subStep?((0,o.wg)(),(0,o.iD)("p",ge,[(0,o.Uk)("Now, we are going to compute the convex hull on each subset of points using Graham's Scan. The processing time is "),(0,o.Wm)(l,{class:"val"},{default:(0,o.w5)((()=>[(0,o.Uk)("O((n / m) (m log m)) = O(n log m)")])),_:1}),(0,o.Uk)(".")])):(0,o.kq)("",!0),2==e.$store.state.subStep?((0,o.wg)(),(0,o.iD)("p",me,[(0,o.Uk)(" Starting from the up-most vertex, a wrapping step can be done by scanning all "),(0,o.Wm)(l,{class:"val"},{default:(0,o.w5)((()=>[(0,o.Uk)("âŒˆm / nâŒ‰")])),_:1}),(0,o.Uk)(" polygons and computing tangents or supporting lines of the polygons through the current vertex. By using binarty search for the tangent finding, the time required for a wrapping step is then "),(0,o.Wm)(l,{class:"val"},{default:(0,o.w5)((()=>[(0,o.Uk)("O((n / m) log m)")])),_:1}),(0,o.Uk)(". Since we are running at most "),(0,o.Wm)(l,{class:"val"},{default:(0,o.w5)((()=>[(0,o.Uk)("m")])),_:1}),(0,o.Uk)(" steps, the total running time is "),(0,o.Wm)(l,{class:"val"},{default:(0,o.w5)((()=>[(0,o.Uk)("O(n log m)")])),_:1}),(0,o.Uk)(" or "),(0,o.Wm)(l,{class:"val"},{default:(0,o.w5)((()=>[(0,o.Uk)("O(h (n / m) log)")])),_:1}),(0,o.Uk)(" when the algorithm finishes. ")])):(0,o.kq)("",!0),3!=e.$store.state.subStep||e.$store.state.rawResults[e.$store.state.round].isCompleted?(0,o.kq)("",!0):((0,o.wg)(),(0,o.iD)("h2",fe,"We are not finishing yet...")),3==e.$store.state.subStep&&e.$store.state.rawResults[e.$store.state.round].isCompleted?((0,o.wg)(),(0,o.iD)("h2",ve,"Process Complete")):(0,o.kq)("",!0),3!=e.$store.state.subStep||e.$store.state.rawResults[e.$store.state.round].isCompleted?(0,o.kq)("",!0):((0,o.wg)(),(0,o.iD)("p",we,[(0,o.Uk)("As you may notice, the "),(0,o.Wm)(l,{class:"val"},{default:(0,o.w5)((()=>[(0,o.Uk)("m")])),_:1}),(0,o.Uk)(" is too small to warp the entire hull. More iterations are required to find a better value.")])),3!=e.$store.state.subStep||e.$store.state.rawResults[e.$store.state.round].isCompleted?(0,o.kq)("",!0):((0,o.wg)(),(0,o.iD)("p",ke,[(0,o.Uk)(" But don't be worry, since the m searching stops as it reaches or exceeds h, the #iterations is at most "),(0,o.Wm)(l,{class:"val"},{default:(0,o.w5)((()=>[(0,o.Uk)("âŒˆlog log nâŒ‰")])),_:1}),(0,o.Uk)(", and the "),(0,o.Wm)(l,{class:"val"},{default:(0,o.w5)((()=>[(0,o.Uk)("t")])),_:1}),(0,o.Uk)("th iteration takes "),(0,o.Wm)(l,{class:"val"},{default:(0,o.w5)((()=>[(0,o.Uk)("O(n"),be,(0,o.Uk)(")")])),_:1}),(0,o.Uk)(" time, therefore the total running time is "),(0,o.Wm)(l,{class:"val"},{default:(0,o.w5)((()=>[(0,o.Uk)("O(n log h)")])),_:1}),(0,o.Uk)(". ")])),3==e.$store.state.subStep&&e.$store.state.rawResults[e.$store.state.round].isCompleted?((0,o.wg)(),(0,o.iD)("p",ye,"The convex hull is successfully computed. Now, you can manually tweak the m value, or restart the demo!")):(0,o.kq)("",!0)])]),(0,o._)("div",Pe,[(0,o._)("div",xe,[(0,o._)("div",_e,[0==e.$store.state.subStep?((0,o.wg)(),(0,o.iD)("button",{key:0,disabled:!e.$store.state.canRun,class:"green",onClick:t[7]||(t[7]=(...e)=>i.groupPoints&&i.groupPoints(...e))},"Group Points",8,Se)):(0,o.kq)("",!0),1==e.$store.state.subStep?((0,o.wg)(),(0,o.iD)("button",{key:1,disabled:!e.$store.state.canRun,class:"green",onClick:t[8]||(t[8]=(...e)=>i.grahamScan&&i.grahamScan(...e))},"Grahamâ€™s Scan",8,Ce)):(0,o.kq)("",!0),2==e.$store.state.subStep?((0,o.wg)(),(0,o.iD)("button",{key:2,disabled:!e.$store.state.canRun,class:"green",onClick:t[9]||(t[9]=(...e)=>i.jarvisMarch&&i.jarvisMarch(...e))},"Jarvisâ€™s March",8,Re)):(0,o.kq)("",!0),3!=e.$store.state.subStep||e.$store.state.rawResults[e.$store.state.round].isCompleted?(0,o.kq)("",!0):((0,o.wg)(),(0,o.iD)("button",{key:3,disabled:!e.$store.state.canRun,class:"green",onClick:t[10]||(t[10]=(...e)=>i.nextRound&&i.nextRound(...e))},"Next Iteration",8,$e)),3==e.$store.state.subStep&&e.$store.state.rawResults[e.$store.state.round].isCompleted?(0,o.kq)("",!0):((0,o.wg)(),(0,o.iD)("button",{key:4,disabled:!e.$store.state.canRun,onClick:t[11]||(t[11]=(...e)=>i.auto&&i.auto(...e))},"Auto",8,Ue)),3==e.$store.state.subStep&&e.$store.state.rawResults[e.$store.state.round].isCompleted?((0,o.wg)(),(0,o.iD)("button",{key:5,disabled:!e.$store.state.canRun,onClick:t[12]||(t[12]=(...e)=>i.runAgain&&i.runAgain(...e))},"Run it again",8,Ee)):(0,o.kq)("",!0),3==e.$store.state.subStep&&e.$store.state.rawResults[e.$store.state.round].isCompleted?((0,o.wg)(),(0,o.iD)("button",{key:6,disabled:!e.$store.state.canRun,onClick:t[13]||(t[13]=(...e)=>i.nextStep&&i.nextStep(...e)),class:"green"},"Try other m values",8,He)):(0,o.kq)("",!0),3==e.$store.state.subStep&&e.$store.state.rawResults[e.$store.state.round].isCompleted?((0,o.wg)(),(0,o.iD)("button",{key:7,disabled:!e.$store.state.canRun,onClick:t[14]||(t[14]=(...e)=>i.restart&&i.restart(...e)),class:"gray"},"Home",8,Me)):(0,o.kq)("",!0)])])])])):(0,o.kq)("",!0),4==e.$store.state.step?((0,o.wg)(),(0,o.iD)("div",De,[We,(0,o._)("div",qe,[(0,o._)("div",Ne,[(0,o._)("div",Ve,[(0,o.wy)((0,o._)("input",{disabled:!e.$store.state.canRun,type:"range",min:"1",max:"100",step:"1",name:"pointsNum",id:"","onUpdate:modelValue":t[15]||(t[15]=e=>i.m=e)},null,8,Ae),[[n.nr,i.m]]),(0,o._)("button",{disabled:!e.$store.state.canRun,class:"green",onClick:t[16]||(t[16]=(...e)=>i.mChans&&i.mChans(...e))}," Run m = "+(0,p.zw)(i.m),9,Te)]),(0,o._)("div",je,[(0,o.wy)((0,o._)("input",{disabled:!e.$store.state.canRun,type:"range",min:"1",max:"100",step:"1",name:"pointsNum",id:"","onUpdate:modelValue":t[17]||(t[17]=e=>a.pointsNum=e)},null,8,Oe),[[n.nr,a.pointsNum]]),(0,o._)("button",{disabled:!e.$store.state.canRun,onClick:t[18]||(t[18]=(...e)=>i.addPoints&&i.addPoints(...e))}," Add "+(0,p.zw)(a.pointsNum)+" Points ",9,ze)]),(0,o._)("button",{disabled:!e.$store.state.canRun,class:"gray",onClick:t[19]||(t[19]=(...e)=>i.restart&&i.restart(...e))}," Home ",8,Ie)])])])):(0,o.kq)("",!0)])}var Ge={name:"ControlPanel",data(){return{pointsNum:20}},methods:{nextStep(){this.$store.dispatch("nextStep")},prevStep(){this.$store.dispatch("prevStep")},addPoints(){this.$store.dispatch("addPoints",{number:this.pointsNum,maxX:document.getElementById("svg").clientWidth,maxY:document.getElementById("svg").clientHeight})},groupPoints(){this.$store.dispatch("groupPoints")},grahamScan(){this.$store.dispatch("grahamScan")},jarvisMarch(){this.$store.dispatch("jarvisMarch")},nextRound(){this.$store.commit("nextRound")},restart(){this.$store.commit("restart")},mChans(){this.$store.dispatch("mChans")},auto(){this.$store.dispatch("auto")},runAgain(){this.$store.commit("prepRunAgain")}},computed:{m:{get(){return this.$store.state.m},set(e){this.$store.commit("setM",e)}},enoughPoints(){return this.$store.state.rawVertices.length>=3}}};const Le=(0,i.Z)(Ge,[["render",Ze]]);var Fe=Le,Je={name:"Chans",components:{Nav:w,SketchPad:D,ControlPanel:Fe},data(){return{}},mounted(){}};const Be=(0,i.Z)(Je,[["render",_]]);var Ye=Be;const Ke=[{path:"/About",name:"About",component:y},{path:"/",name:"Chans",component:Ye},{path:"/:catchAll(.*)",redirect:"/"}],Xe=(0,d.p7)({history:(0,d.PO)("/ConvexHull-ChansAlgorithm/"),routes:Ke});var Qe=Xe,et=(s(560),s(3907)),tt=s(6512),st=s(7327);class nt{constructor(e,t,s=nt.DefaultColor){(0,st.Z)(this,"xPos",void 0),(0,st.Z)(this,"yPos",void 0),(0,st.Z)(this,"predecessor",void 0),(0,st.Z)(this,"color",void 0),this.xPos=e,this.yPos=t,this.color=s}getR(){return this.color==nt.DefaultColor?nt.DefaultR:nt.MaxR}static xSort(e,t){return e.xPos>t.xPos?1:e.xPos<t.xPos?-1:0}static ySort(e,t){return e.yPos>t.yPos?1:e.yPos<t.yPos?-1:0}static orient(e,t,s){return e.xPos*t.yPos+t.xPos*s.yPos+s.xPos*e.yPos-(e.xPos*s.yPos+t.xPos*e.yPos+s.xPos*t.yPos)}static degree(e,t,s){let n=[e.xPos-t.xPos,e.yPos-t.yPos],o=[s.xPos-t.xPos,s.yPos-t.yPos],r=(n[0]*o[0]+n[1]*o[1])/(Math.sqrt(Math.pow(n[0],2)+Math.pow(n[1],2))*Math.sqrt(Math.pow(o[0],2)+Math.pow(o[1],2)));return Math.acos(r)}}(0,st.Z)(nt,"DefaultColor","#74ff99"),(0,st.Z)(nt,"DefaultR",5),(0,st.Z)(nt,"MaxR",6);class ot{constructor(e,t,s="#000000"){(0,st.Z)(this,"begin",void 0),(0,st.Z)(this,"end",void 0),(0,st.Z)(this,"color","#74ff99"),this.begin=e,this.end=t,this.color=s}get x0(){return this.begin.xPos}get y0(){return this.begin.yPos}get x1(){return this.end.xPos}get y1(){return this.end.yPos}}class rt{constructor(e){(0,st.Z)(this,"P",void 0),(0,st.Z)(this,"steps",[]),this.P=e}static getInstance(e){if(!(e.length<3)){if(void 0===rt.instance)return rt.instance=new rt(e),rt.instance;{let t=rt.instance;return t.P=e,t.subP=[],t.subCH=[],t}}}Hull(){this.steps=[];for(let e=1;1;e++){this.steps.push({m:0,r:0,subP:[],pLen:this.P.length,subCH:[],edgeLen:0,JM:{mEdges:[],mVertices:[],mScans:[]},isCompleted:!1});let t=Math.min(Math.pow(2,Math.pow(2,e)),this.P.length);this.steps[this.steps.length-1].m=t;let s=this.PartialHull(t);if(null!=s)return this.steps}}mHull(e){this.steps=[],this.steps.push({m:0,r:0,subP:[],pLen:this.P.length,subCH:[],edgeLen:0,JM:{mEdges:[],mVertices:[],mScans:[]},isCompleted:!1}),this.steps[this.steps.length-1].m=e;this.PartialHull(e);return this.steps}PartialHull(e){let t=Math.ceil(this.P.length/e);this.steps[this.steps.length-1].r=t;let s=[];for(let r=0;r<t;r++)s.push(this.P.slice(e*r,e*(r+1)));this.steps[this.steps.length-1].subP=s;let n=[];for(let r of s){let e=this.GrahamScan(r);n.push(e),this.steps[this.steps.length-1].edgeLen+=e.edges.length}this.steps[this.steps.length-1].subCH=n;let o=this.JarvisMarch(n,t,e);return null==o?null:o}GrahamScan(e){if(e.length<2)return{vertices:[e[0]],edges:[new ot(e[0],e[0])]};let t=e.sort(nt.xSort),s=[t[0],t[1]];for(let r=2;r<t.length;r++){while(s.length>=2&&nt.orient(s[s.length-2],s[s.length-1],t[r])<=0)s.pop();s.push(t[r])}let n=[t[t.length-1],t[t.length-2]];for(let r=t.length-3;r>=0;r--){while(n.length>=2&&nt.orient(n[n.length-2],n[n.length-1],t[r])<=0)n.pop();n.push(t[r])}let o=[];for(let r=1;r<s.length;r++)o.push(new ot(s[r-1],s[r]));for(let r=1;r<n.length;r++)o.push(new ot(n[r-1],n[r]));return s.pop(),n.pop(),{vertices:s.concat(n),edges:o}}JarvisMarch(e,t,s){let n=[],o=this.P[0];for(let l of this.P)l.yPos<o.yPos&&(o=l);let r=[new nt(Number.MIN_SAFE_INTEGER,0),o];for(let l=1;l<=s;l++){n.push([]);for(let o=0;o<t;o++){let t=[...e[o].vertices],s=t.indexOf(r[l-1]);s>-1&&t.splice(s,1),s=t.indexOf(r[l]),s>-1&&t.splice(s,1),t.length<1||n[l-1].push(this.bSearch(t,0,t.length-1,r[l-1],r[l]))}let s=Number.MIN_SAFE_INTEGER;r.push(n[l-1][0]);for(let e of n[l-1])nt.degree(r[l-1],r[l],e)>s&&(s=nt.degree(r[l-1],r[l],e),r[l+1]=e);if(r[l+1]===r[1]){let e=r.slice(1,r.length);this.steps[this.steps.length-1].JM.mScans=n,this.steps[this.steps.length-1].JM.mVertices=e;let t=[];for(let s=1;s<r.length;s++)t.push(new ot(e[s-1],e[s]));return this.steps[this.steps.length-1].JM.mEdges=t,this.steps[this.steps.length-1].isCompleted=!0,e}}this.steps[this.steps.length-1].JM.mScans=n;let a=r.slice(1,r.length);this.steps[this.steps.length-1].JM.mVertices=a;let i=[];for(let l=1;l<r.length;l++)i.push(new ot(a[l-1],a[l]));return this.steps[this.steps.length-1].JM.mEdges=i,null}bSearch(e,t,s,n,o){if(t==s)return e[t];let r=t+s>>1;return nt.degree(n,o,e[t])>nt.degree(n,o,e[s])?nt.degree(n,o,e[r])<nt.degree(n,o,e[s])?this.bSearch(e,t,r,n,o):nt.degree(n,o,e[r+1])>nt.degree(n,o,e[r])?this.bSearch(e,r+1,s,n,o):nt.degree(n,o,e[r+1])==nt.degree(n,o,e[r])?e[r]:this.bSearch(e,t,r,n,o):nt.degree(n,o,e[r])<nt.degree(n,o,e[s])||nt.degree(n,o,e[r+1])>nt.degree(n,o,e[r])?this.bSearch(e,r+1,s,n,o):nt.degree(n,o,e[r+1])==nt.degree(n,o,e[r])?e[r]:this.bSearch(e,t,r,n,o)}lSearch(e,t,s){let n,o=Number.MIN_SAFE_INTEGER;for(let r of e)nt.degree(t,s,r)>=o&&(o=nt.degree(t,s,r),n=r);return n}}(0,st.Z)(rt,"instance",void 0);var at=s(3313),it=s.n(at),lt=(0,et.MT)({state:{drawable:!0,resizeTimeoutId:void 0,resizeRequired:!1,svgPadding:nt.MaxR+4,step:0,canRun:!0,round:0,subStep:0,speed:40,rawVertices:[],rawResults:[],subHullEdges:[],fullHullEdges:[],scanEdge:void 0,m:6},mutations:{updatePosition(e,t){if(0==e.rawVertices.length)return;let s=e.rawVertices[0].xPos,n=e.rawVertices[0].xPos,o=e.rawVertices[0].yPos,r=e.rawVertices[0].yPos;e.rawVertices.forEach((e=>{e.xPos<s&&(s=e.xPos),e.xPos>n&&(n=e.xPos),e.yPos<o&&(o=e.yPos),e.yPos>r&&(r=e.yPos)})),e.rawVertices.forEach((a=>{a.xPos=(a.xPos-s)/(n-s)*(t.width-2*e.svgPadding)+e.svgPadding,a.yPos=(a.yPos-o)/(r-o)*(t.height-2*e.svgPadding)+e.svgPadding}))},setSpeed(e,t){e.speed=t},updateStep(e,t){e.step+=t},updateCanRun(e,t){e.canRun=t},nextRound(e){e.round++},nextSubStep(e){e.subStep++},addVertex(e,t){if(1==e.step||4==e.step){for(let s of e.rawVertices)if(s.xPos==t.x&&s.yPos==t.y)return;e.rawVertices.push(new nt(t.x,t.y))}},addEdge(e,t){e.subHullEdges.push(t)},setEdges(e,t){e.subHullEdges=t},setScanEdge(e,t){e.scanEdge=t},addFullHullEdge(e,t){e.fullHullEdges.push(t)},replaceLastFullHullEdge(e,t){e.fullHullEdges[e.fullHullEdges.length-1]=t},setResults(e,t){for(let s of t)s.colors=(0,tt.Z)({count:s.r,chromaMin:50,lightMin:45});e.rawResults=t},nextRound(e,t=void 0){for(let s of e.rawVertices)s.color=nt.DefaultColor;e.subStep=0,e.fullHullEdges=[],e.subHullEdges=[],e.round+=1,t&&t()},prepRunAgain(e,t=void 0){for(let s of e.rawVertices)s.color=nt.DefaultColor;e.subStep=0,e.round=0,e.fullHullEdges=[],e.subHullEdges=[]},restart(e){e.rawVertices=[],e.rawResults=[],e.subStep=0,e.round=0,e.step=0,e.fullHullEdges=[],e.subHullEdges=[]},setM(e,t){e.m=t}},actions:{nextStep({commit:e,state:t,dispatch:s}){if(2==t.step&&s("computeChans"),3==t.step){for(let e of t.rawVertices)e.color=nt.DefaultColor;t.subStep=0,t.round=0,t.fullHullEdges=[],t.subHullEdges=[],t.rawResults=[]}e("updateStep",1)},prevStep({commit:e,state:t}){t.step-1==0?e("restart"):e("updateStep",-1)},async addPoints({commit:e,state:t},s){function n(e,t){return e=Math.ceil(e),t=Math.floor(t),Math.floor(Math.random()*(t-e))+e}e("updateCanRun",!1);let o=s.number;while(o>0)e("addVertex",{x:n(t.svgPadding,s.maxX-t.svgPadding),y:n(t.svgPadding,s.maxY-t.svgPadding)}),await it()(t.speed),o--;e("updateCanRun",!0)},computeChans({state:e,commit:t}){let s=rt.getInstance(e.rawVertices);s?t("setResults",s.Hull()):alert("You have to add more dots!!!!")},async groupPoints({state:e,commit:t},s=void 0){t("updateCanRun",!1);let n=e.rawResults[e.round].pLen,o=0,r=0;while(n>0){let t=e.rawResults[e.round].colors[o];e.rawResults[e.round].subP[o][r].color=t,e.rawResults[e.round].subP[o].length-1>r?r++:(r=0,o++),n--,await it()(e.speed)}t("nextSubStep"),s?setTimeout((()=>{s()}),500):t("updateCanRun",!0)},async grahamScan({state:e,commit:t},s=void 0){t("updateCanRun",!1);let n=e.rawResults[e.round].edgeLen,o=0,r=0;e.subHullEdges=[];while(n>0){let s=e.rawResults[e.round].colors[o];e.rawResults[e.round].subCH[o].edges[r].color=s,t("addEdge",e.rawResults[e.round].subCH[o].edges[r]),e.rawResults[e.round].subCH[o].edges.length-1>r?r++:(r=0,o++),n--,await it()(e.speed)}t("nextSubStep"),s?setTimeout((()=>{s()}),500):t("updateCanRun",!0)},async jarvisMarch({state:e,commit:t},s=void 0){t("updateCanRun",!1);let n=e.rawResults[e.round].JM.mScans,o=e.rawResults[e.round].JM.mVertices;e.fullHullEdges=[];let r=0;for(let l of n)r+=l.length;let a=0,i=0;while(r>0){let s=new ot(o[a],n[a][i]);if(t("setScanEdge",s),0==i)s.color="#FF0051",t("addFullHullEdge",s);else{let n=0==a?new nt(Number.MIN_SAFE_INTEGER,0):e.fullHullEdges[e.fullHullEdges.length-2].begin,o=nt.degree(n,e.fullHullEdges[e.fullHullEdges.length-1].begin,e.fullHullEdges[e.fullHullEdges.length-1].end),r=nt.degree(n,s.begin,s.end);r>o&&(s.color="#FF0051",t("replaceLastFullHullEdge",s))}n[a].length-1>i?i++:(e.fullHullEdges[e.fullHullEdges.length-1].color="white",i=0,a++),r--,await it()(e.speed)}t("setScanEdge",void 0),t("nextSubStep"),s&&e.rawResults.length-1>e.round?setTimeout((()=>{s()}),500):t("updateCanRun",!0)},mChans({commit:e,state:t,dispatch:s}){let n=rt.getInstance(t.rawVertices);if(n){e("setResults",n.mHull(t.m));for(let e of t.rawVertices)e.color=nt.DefaultColor;t.fullHullEdges=[],t.subHullEdges=[],s("groupPoints",(()=>{s("grahamScan",(()=>{s("jarvisMarch")}))})),t.subStep=0,t.round=0}else alert("You have to add more dots!!!!")},auto({commit:e,state:t,dispatch:s},n=!1){switch(t.subStep){case 0:s("groupPoints",(()=>{s("grahamScan",(()=>{s("jarvisMarch",(()=>{e("nextRound",(()=>{n||s("auto",n)}))}))}))}));break;case 1:s("grahamScan",(()=>{s("jarvisMarch",(()=>{e("nextRound",(()=>{n||s("auto",n)}))}))}));break;case 2:s("jarvisMarch",(()=>{e("nextRound",(()=>{n||s("auto",n)}))}));break;case 3:e("nextRound",(()=>{n||s("auto",n)}));break}}},getters:{vertices(e){return 0==e.step?[]:e.rawVertices},edges(e){return 0==e.step?[]:e.subHullEdges}},modules:{}}),ut=s(5205);(0,ut.z)("/ConvexHull-ChansAlgorithm/service-worker.js",{ready(){console.log("App is being served from cache by a service worker.\nFor more details, visit https://goo.gl/AFskqB")},registered(){console.log("Service worker has been registered.")},cached(){console.log("Content has been cached for offline use.")},updatefound(){console.log("New content is downloading.")},updated(){console.log("New content is available; please refresh.")},offline(){console.log("No internet connection found. App is running in offline mode.")},error(e){console.error("Error during service worker registration:",e)}});const dt=(0,n.ri)(u);dt.use(lt),dt.use(Qe),dt.mount("#app")},3313:function(e){const t=async e=>new Promise((t=>setTimeout(t,e)));e.exports=t}},t={};function s(n){var o=t[n];if(void 0!==o)return o.exports;var r=t[n]={exports:{}};return e[n].call(r.exports,r,r.exports,s),r.exports}s.m=e,function(){var e=[];s.O=function(t,n,o,r){if(!n){var a=1/0;for(d=0;d<e.length;d++){n=e[d][0],o=e[d][1],r=e[d][2];for(var i=!0,l=0;l<n.length;l++)(!1&r||a>=r)&&Object.keys(s.O).every((function(e){return s.O[e](n[l])}))?n.splice(l--,1):(i=!1,r<a&&(a=r));if(i){e.splice(d--,1);var u=o();void 0!==u&&(t=u)}}return t}r=r||0;for(var d=e.length;d>0&&e[d-1][2]>r;d--)e[d]=e[d-1];e[d]=[n,o,r]}}(),function(){s.n=function(e){var t=e&&e.__esModule?function(){return e["default"]}:function(){return e};return s.d(t,{a:t}),t}}(),function(){s.d=function(e,t){for(var n in t)s.o(t,n)&&!s.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})}}(),function(){s.g=function(){if("object"===typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"===typeof window)return window}}()}(),function(){s.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)}}(),function(){var e={143:0};s.O.j=function(t){return 0===e[t]};var t=function(t,n){var o,r,a=n[0],i=n[1],l=n[2],u=0;if(a.some((function(t){return 0!==e[t]}))){for(o in i)s.o(i,o)&&(s.m[o]=i[o]);if(l)var d=l(s)}for(t&&t(n);u<a.length;u++)r=a[u],s.o(e,r)&&e[r]&&e[r][0](),e[r]=0;return s.O(d)},n=self["webpackChunkchans_algorithm"]=self["webpackChunkchans_algorithm"]||[];n.forEach(t.bind(null,0)),n.push=t.bind(null,n.push.bind(n))}();var n=s.O(void 0,[998],(function(){return s(613)}));n=s.O(n)})();
//# sourceMappingURL=app.cdce5d01.js.map